{% extends 'base.html' %}

{% block title %}
–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
{% endblock %}

{% block style %}
  .hover-wrapper {
      position: relative;
      cursor: pointer;
    }
    .hover-card {
      position: absolute;
      top: 50%;            /* drop below the cell text  */
      left: 100%;
      z-index: 9;        /* above table borders       */
      display: none;
      width: 240px;
    }
    .hover-wrapper:hover .hover-card,
    .hover-wrapper:focus .hover-card {
      display: block;
    }

    .main-page-layout {
      padding-left: 260px;
    }

    .filter-panel {
      position: fixed;
      top: 96px;
      left: 32px;
      width: 320px;
      max-height: calc(100vh - 128px);
      overflow-y: auto;
      z-index: 1030;
    }

    .filter-panel form {
      padding-bottom: 1rem;
    }

    .filter-panel .form-group + .form-group {
      margin-top: 1rem;
    }

    .filter-tile-list {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem;
      max-height: 220px;
      overflow-y: auto;
      padding-right: .25rem;
    }

    .filter-tile {
      display: inline-flex;
      align-items: center;
      gap: .35rem;
      border: 1px solid var(--bs-border-color);
      border-radius: .75rem;
      padding: .35rem .65rem;
      background: var(--bs-light);
      cursor: pointer;
      font-size: .875rem;
      transition: all .2s ease;
    }

    .filter-tile input[type="checkbox"] {
      margin: 0;
    }

    .filter-tile:has(input[type="checkbox"]:checked) {
      border-color: var(--bs-primary);
      background: rgba(var(--bs-primary-rgb), 0.12);
    }

    .autocomplete-suggestions {
      margin-top: .5rem;
      border: 1px solid var(--bs-border-color);
      border-radius: .5rem;
      background: #fff;
      max-height: 210px;
      overflow-y: auto;
      box-shadow: 0 .5rem 1rem rgba(0,0,0,.08);
    }

    .autocomplete-suggestion-item {
      width: 100%;
      border: 0;
      background: transparent;
      text-align: left;
      padding: .45rem .65rem;
      font-size: .875rem;
    }

    .autocomplete-suggestion-item:hover,
    .autocomplete-suggestion-item:focus {
      background: var(--bs-light);
    }

    .autocomplete-suggestion-path {
      color: var(--bs-secondary-color);
      font-size: .75rem;
    }

    .table-area {
      margin-top: 2rem;
    }

    @media (max-width: 991.98px) {
      .main-page-layout {
        padding-right: 0;
      }

      .filter-panel {
        position: static;
        width: 100%;
        max-height: none;
        margin-top: 1.5rem;
        right: auto;
      }

      .table-area {
        margin-top: 1.5rem;
      }
    }
{% endblock %}

{% block body %}
<div id="mainproduct-block">
  <div class="container-fluid main-page-layout">
    {% include 'main/includes/table.html' %}
  </div>

  <div class="filter-panel card shadow-sm mt-4">
    <div class="card-body">
      <h2 class="h4">–§–∏–ª—å—Ç—Ä—ã</h2>
      <form method="get" class="form" id="main-filter-form">
        {{ filter_form.media }}

        <div id="filters-update-sink" class="d-none"></div>

        <div class="form-group mt-3">
          <label for="{{ filter_form.search.id_for_label }}">{{ filter_form.search.label }}</label>
          {{ filter_form.search }}
        </div>

        <div class="form-group mt-3">
          <label for="{{ filter_form.anti_search.id_for_label }}">{{ filter_form.anti_search.label }}</label>
          {{ filter_form.anti_search }}
        </div>


        {% if filter_form.available %}
        <div class="form-group mt-3">
          <label for="{{ filter_form.available.id_for_label }}">{{ filter_form.available.label }}</label>
          {{ filter_form.available }}
        </div>
        {% endif %}
        
        {% include 'main/includes/filter_field.html' with field=filter_form.category container_id='category-filter-container' collapse_id='category-filter-collapse' is_category=True category_tree=category_tree selected_categories=selected_categories available_options=None collapsible=False %}
        
        {% include 'main/includes/filter_field.html' with field=filter_form.manufacturer container_id='manufacturer-filter-container' collapse_id='manufacturer-filter-collapse' available_options=available_manufacturers available_options_label='–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–∏' collapsible=False %}
        
        {% include 'main/includes/filter_field.html' with field=filter_form.supplier container_id='supplier-filter-container' collapse_id='supplier-filter-collapse' available_options=available_suppliers available_options_label='–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∏' collapsible=False %}



        <div class="mt-4 d-flex gap-2">
            <button type="submit" class="btn btn-primary flex-grow-1">
              üîç –ò—Å–∫–∞—Ç—å
            </button>
            <a href="{% url 'main-product-sync'%}" class="btn btn-success">
              <i class="bi bi-recycle"></i> –û–±–Ω–æ–≤–∏—Ç—å
            </a>
        </div>
      </form>
    </div>
  </div>
</div>
{% endblock %}

{% block script %}
<script>
  document.body.addEventListener('htmx:configRequest', (evt) => {
    evt.detail.headers['X-CSRFToken'] = '{{ csrf_token }}';
  });

  const enhanceSelect = (selector) => {
    const element = window.jQuery ? window.jQuery(selector) : null;
    if (element && element.length && element.select2) {
      element.select2({
        width: '100%',
        placeholder: element.data('placeholder') || '',
        allowClear: true,
        language: {
          noResults: () => '–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ',
          searching: () => '–ü–æ–∏—Å–∫‚Ä¶'
        }
      });
    }
  };

  const initDynamicFilters = () => {
    enhanceSelect('#id_supplier');
    enhanceSelect('#id_manufacturer');
  };

  const normalizeText = (value) => (value || '').trim().toLowerCase();

  const initAutocompleteFilters = () => {
    const containers = document.querySelectorAll('[data-autocomplete-filter]');
    containers.forEach((container) => {
      if (container.dataset.autocompleteInitialized === 'true') {
        return;
      }

      const searchInput = container.querySelector('[data-autocomplete-search]');
      const optionItems = Array.from(container.querySelectorAll('[data-option-item]'));
      const suggestions = container.querySelector('[data-autocomplete-suggestions]');

      if (!searchInput || !optionItems.length || !suggestions) {
        return;
      }

      const getItemLabel = (item) => {
        const optionLabel = item.querySelector('[data-option-label]');
        return normalizeText(optionLabel ? optionLabel.textContent : '');
      };

      const updateSuggestions = (term) => {
        if (!term) {
          suggestions.innerHTML = '';
          suggestions.classList.add('d-none');
          return;
        }

        const matchedItems = optionItems
          .filter((item) => getItemLabel(item).includes(term))
          .slice(0, 8);

        if (!matchedItems.length) {
          suggestions.innerHTML = '';
          suggestions.classList.add('d-none');
          return;
        }

        suggestions.innerHTML = matchedItems.map((item, index) => {
          const checkbox = item.querySelector('input[type="checkbox"]');
          const selected = checkbox && checkbox.checked ? ' ‚úì' : '';
          const label = item.querySelector('span') ? item.querySelector('span').textContent.trim() : '';
          return `<button type="button" class="autocomplete-suggestion-item" data-suggestion-index="${index}">${label}${selected}</button>`;
        }).join('');
        suggestions.classList.remove('d-none');

        suggestions.querySelectorAll('[data-suggestion-index]').forEach((element) => {
          element.addEventListener('click', () => {
            const selectedItem = matchedItems[Number(element.dataset.suggestionIndex)];
            if (!selectedItem) {
              return;
            }

            const checkbox = selectedItem.querySelector('input[type="checkbox"]');
            if (checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
            selectedItem.classList.remove('d-none');
            selectedItem.scrollIntoView({ block: 'nearest' });
          });
        });
      };

      const applyFilter = () => {
        const term = normalizeText(searchInput.value);
        optionItems.forEach((item) => {
          const shouldShow = !term || getItemLabel(item).includes(term);
          item.classList.toggle('d-none', !shouldShow);
        });
        updateSuggestions(term);
      };

      searchInput.addEventListener('input', applyFilter);
      applyFilter();
      container.dataset.autocompleteInitialized = 'true';
    });
  };
  
  const setToggleButtonState = (button, isExpanded) => {
    const expandedText = button.getAttribute('data-expanded-text') || button.textContent;
    const collapsedText = button.getAttribute('data-collapsed-text') || button.textContent;
    button.textContent = isExpanded ? expandedText : collapsedText;
    button.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
  };

  const initFilterToggle = (button) => {
    if (!button || button.dataset.filterToggleInitialized === 'true') {
      return;
    }

    const targetSelector = button.getAttribute('data-bs-target');
    if (!targetSelector) {
      return;
    }

    const target = document.querySelector(targetSelector);
    if (!target) {
      return;
    }

    const updateState = () => {
      const isExpanded = target.classList.contains('show');
      setToggleButtonState(button, isExpanded);
    };

    target.addEventListener('shown.bs.collapse', () => setToggleButtonState(button, true));
    target.addEventListener('hidden.bs.collapse', () => setToggleButtonState(button, false));

    updateState();

    button.dataset.filterToggleInitialized = 'true';
  };

  const initFilterToggles = () => {
    const buttons = document.querySelectorAll('[data-filter-toggle="button"]');
    buttons.forEach(initFilterToggle);
  };

  const debounce = (fn, delay = 300) => {
    let timerId;
    return (...args) => {
      if (timerId) {
        clearTimeout(timerId);
      }
      timerId = window.setTimeout(() => {
        timerId = null;
        fn(...args);
      }, delay);
    };
  };

  const getFilterForm = () => document.getElementById('main-filter-form');

  const requestTableUpdate = () => {
    if (!window.htmx) {
      return;
    }

    const form = getFilterForm();
    if (!form) {
      return;
    }

    const params = new URLSearchParams(new FormData(form));
    params.delete('page');

    const queryString = params.toString();
    const tableUrl = '{{ table_update_url|escapejs }}';
    const separator = tableUrl.includes('?') ? '&' : '?';
    const url = queryString ? `${tableUrl}${separator}${queryString}` : tableUrl;

    window.htmx.ajax('GET', url, {
      target: '#main-table-container',
      swap: 'outerHTML',
    });

    const newLocation = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
    window.history.replaceState({}, '', newLocation);
  };

  const scheduleTableUpdate = debounce(requestTableUpdate, 500);

  const shouldIgnoreAutoUpdate = (element) => {
    return Boolean(element && element.dataset && element.dataset.ignoreAutoUpdate === 'true');
  };

  const registerAutoUpdate = () => {
    const form = getFilterForm();
    if (!form || form.dataset.autoUpdateInitialized === 'true') {
      return;
    }

    form.addEventListener('input', (event) => {
      const target = event.target;
      if (!target) {
        return;
      }

      if (target.matches('input[type="text"], input[type="search"], textarea')) {
        if (shouldIgnoreAutoUpdate(target)) {
          return;
        }
        scheduleTableUpdate();
      }
    });

    form.addEventListener('change', (event) => {
      const target = event.target;
      if (!target) {
        return;
      }

      if (target.matches('input, select, textarea')) {
        if (shouldIgnoreAutoUpdate(target)) {
          return;
        }
        requestTableUpdate();
      }
    });

    form.dataset.autoUpdateInitialized = 'true';
  };

  const initCategoryFilterSearch = () => {
    const containers = document.querySelectorAll('[data-category-filter]');
    containers.forEach((container) => {
      if (container.dataset.categoryFilterInitialized === 'true') {
        return;
      }

      const searchInput = container.querySelector('[data-category-filter-search]');
      const tree = container.querySelector('[data-category-tree]');
      const suggestions = container.querySelector('[data-category-suggestions]');

      if (!searchInput || !tree || !suggestions) {
        return;
      }

      const getChildList = (parent) => {
        return Array.from(parent.children).find((element) => element.tagName === 'UL');
      };

      const getChildNodes = (parent) => {
        const list = getChildList(parent);
        if (!list) {
          return [];
        }
        return Array.from(list.children).filter((child) => child.matches('[data-category-node]'));
      };

      const getRootNodes = () => {
        const rootList = tree.querySelector('ul');
        if (!rootList) {
          return [];
        }
        return Array.from(rootList.children).filter((child) => child.matches('[data-category-node]'));
      };

      const getNodePath = (node) => {
        const path = [];
        let current = node;

        while (current && current.matches('[data-category-node]')) {
          const label = current.querySelector('[data-category-label]');
          if (label) {
            path.push(label.textContent.trim());
          }
          const parentNode = current.parentElement ? current.parentElement.closest('[data-category-node]') : null;
          current = parentNode;
        }

        return path.reverse();
      };

      const collectAllNodes = () => Array.from(tree.querySelectorAll('[data-category-node]'));

      const buildSuggestions = (term) => {
        if (!term) {
          suggestions.classList.add('d-none');
          suggestions.innerHTML = '';
          return;
        }

        const matches = collectAllNodes()
          .filter((node) => (node.dataset.categoryName || '').includes(term))
          .slice(0, 8);

        if (!matches.length) {
          suggestions.classList.add('d-none');
          suggestions.innerHTML = '';
          return;
        }

        suggestions.innerHTML = matches.map((node) => {
          const path = getNodePath(node);
          const title = path[path.length - 1] || '';
          const branch = path.slice(0, -1).join(' / ');
          return `
            <button type="button" class="autocomplete-suggestion-item" data-category-suggestion="${node.dataset.categoryId}">
              <div>${title}</div>
              ${branch ? `<div class="autocomplete-suggestion-path">${branch}</div>` : ''}
            </button>
          `;
        }).join('');

        suggestions.classList.remove('d-none');

        suggestions.querySelectorAll('[data-category-suggestion]').forEach((element) => {
          element.addEventListener('click', () => {
            const nodeId = element.dataset.categorySuggestion;
            const node = tree.querySelector(`[data-category-node][data-category-id="${nodeId}"]`);
            if (!node) {
              return;
            }

            node.scrollIntoView({ block: 'center' });
            const checkbox = node.querySelector('input[type="checkbox"]:not([disabled])');
            if (checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
          });
        });
      };

      const filterTree = () => {
        const term = normalizeText(searchInput.value);

        if (!term) {
          tree.querySelectorAll('[data-category-node]').forEach((node) => {
            node.classList.remove('d-none');
          });
          buildSuggestions(term);
          return;
        }

        const applyFilter = (node, forceShow = false) => {
          const name = (node.dataset.categoryName || '').toLowerCase();
          const children = getChildNodes(node);
          const matchesSelf = name.includes(term);
          const shouldShowChildren = forceShow || matchesSelf;

          let hasMatchingChild = false;
          children.forEach((child) => {
            if (applyFilter(child, shouldShowChildren)) {
              hasMatchingChild = true;
            }
          });

          const shouldShow = shouldShowChildren || hasMatchingChild;
          node.classList.toggle('d-none', !shouldShow);
          return shouldShow;
        };

        getRootNodes().forEach((node) => {
          applyFilter(node);
        });

        buildSuggestions(term);
      };

      const debouncedFilter = debounce(filterTree, 150);
      searchInput.addEventListener('input', debouncedFilter);
      filterTree();
      container.dataset.categoryFilterInitialized = 'true';
    });
  };

  document.addEventListener('DOMContentLoaded', () => {
    initDynamicFilters();
    initFilterToggles();
    initAutocompleteFilters();
    registerAutoUpdate();
    initCategoryFilterSearch();
    const shoppingTabModal = document.getElementById('shoppingTabSelectionModal');
    if (shoppingTabModal) {
      const modalContent = shoppingTabModal.querySelector('#shopping-tab-selection-modal-content');
      const defaultMarkup = modalContent ? modalContent.innerHTML : '';
      shoppingTabModal.addEventListener('hidden.bs.modal', () => {
        if (modalContent) {
          modalContent.innerHTML = defaultMarkup;
        }
      });
    }
  });

  const shouldEnhance = (target) => {
    if (!target) {
      return false;
    }
    return ['supplier-filter-container', 'manufacturer-filter-container'].includes(target.id);
  };

  document.body.addEventListener('htmx:afterSwap', (event) => {
    if (event.target && event.target.id === 'filters-update-sink') {
      initDynamicFilters();
      initFilterToggles();
      initAutocompleteFilters();
      registerAutoUpdate();
      initCategoryFilterSearch();
    }
  });

  document.body.addEventListener('htmx:oobAfterSwap', (event) => {
    if (shouldEnhance(event.detail && event.detail.target)) {
      initDynamicFilters();
    }
    initFilterToggles();
    initAutocompleteFilters();
    registerAutoUpdate();
    initCategoryFilterSearch();
  });
</script>
{% endblock %}
